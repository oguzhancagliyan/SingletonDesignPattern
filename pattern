### Singleton Design Pattern

Creational Patternlerden Singleton Design Patterni inceleyeceğiz.
**Singleton Design Patternin kullanılma amacı nesnenin tek olmasını sağlamaktır.**
Genelde singleton sınıfı **sealed** işaretlenerek kalıtım alması engellenir.Çünkü bu sınıfların kullanılma amacı kalıtım vermek değildir.
Thread safe ve thread safe olmayan yaklaşımları mevcuttur.Thread safe olmayan yaklaşımları multi thread uygulamalarda kullanmak sakıncalıdır.
Öncelikle thread safe olmayan yaklaşımları inceleyelim
```c#	   
    //multi thread uygulamalarda farklı threadler aynı anda hitlemeye çalıştığında instance null olarak görebileceğinden farklı threadler if bloğunun içerisine girip 2 instance yaratabilir.Bu durum singleton mantığına aykırıdır.
    //Multi thread uygulamalarda bu versiyonu kullanılmamalıdır.
public sealed class Singleton
    {
        private static Singleton instance = new Singleton();
        //classtan instance yaratılmaması için construconstructoru private işaretlenir
        private Singleton()
        {

        }
        public static Singleton Instance
        {
            get
            {
               
                return instance;
            }
        }
    }
	
		//Kullanım Örneği
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            //Singleton instance = new Singleton();
			//sınıf private construconstructora sahip olduğundan nesneden new anahtar kelimesi ile yeni bir örneği yaratılamaz.
            var singleton1 = Singleton.Instance;
            var singleton2 = Singleton.Instance;
        }    
```

Şimdi thread safe yaklaşımları inceleyelim.

- 1)Thread safe olan temel yaklaşım
```c#	

  public sealed class Singleton
    {        
        public static Singleton instance = null;
        //lock işlemi için kullanılacak obje
        public static readonly object padlock = new object();
        //ctor internal instance alınmaması için
        Singleton()
        {

        }
        public static Singleton Instance
        {
            get
            {
                
                //thread paylaşılan padlock objesini locklayacağı için diğer thread bu bloğa girmeyip diğer threadin bu objeyle işinin bitmesini bekleyecektir.
                //lock işlemini sağlayan ilk thread class henüz instance alınmadıysa yeni bir instance yaratacağı için bekleyen diğer threadler yaratılmış örneğini alıp işlemine devam edecektir.
                //performans açısından her istek geldiğinde  locklama işlemi gerçekleşip sonunda da locklama işlemi bitmesi memory açısından kayba yol açar. 
                lock (padlock)
                {
                    if (instance == null)
                    {
                        instance = new Singleton();
                    }
                    return instance;
                }
                
            }
        }
    }
```
- 2)Lock yöntemi kullanılarak oluşturulan Thread Safe yaklaşım.
```c#	   

public sealed class Singleton
    {
        //multi thread uygulamalarda thread safe için kullanılack basit bir yöntem.
        public static Singleton instance = null;
        //lock işlemi için kullanılacak obje
        public static readonly object lockObject = new object();
        //construconstructora internal instance alınmaması için
        Singleton()
        {

        }
        public static Singleton Instance
        {
            get
            {
                
                //thread paylaşılan padlock objesini locklayacağı için diğer thread bu bloğa girmeyip diğer threadin bu objeyle işinin bitmesini bekleyecektir.
                //lock işlemini sağlayan ilk thread, class henüz instance alınmadıysa yeni bir instance yaratacağı için bekleyen diğer threadler yaratılmış örneğini alıp işlemine devam edecektir.
                //performans açısından her istek geldiğinde  locklama işlemi gerçekleşip sonunda da locklama işlemi bitmesi memory açısından kayba yol açar. 
                lock (lockObject)
                {
                    if (instance == null)
                    {
                        instance = new Singleton();
                    }
                    return instance;
                }
                
            }
        }
    }
	
	  //Kullanım Örneği
	  static void Main(string[] args)
        {

            var singObj = Singleton.Instance;
           
        }
```
- 3)Çift kontrollü ve lock objesi kullanılarak oluşturulan Thread safe yaklaşım.

```c#

   public sealed class Singleton
    {        
        public static  Singleton instance = null;
        public static readonly object padlock = new object();
        Singleton()
        {

        }
        public static Singleton Instance
        {
            get
            {
                if (instance == null)
                {
                    lock (padlock)
                    {
                        if (instance == null)
                        {
                            instance = new Singleton();
                        }
                      
                    }
                }
                return instance;
            }
        }
    }
```

- 4)Lock yöntemi kullanılmadan oluşturulan Thread safe yaklaşım.
```c#	   
	public sealed class Singleton
    {
        
        //Singleton.Instance isteğinde çalışma sırası şu şekilde olacak;
        //öncelikle **private static readonly Singleton instance = new Singleton();** okunacaktır fakat statik bir constructora sahip olduğu için henüz bir instance objesi yaratılmayacaktır.
        //nesne yaratılma okuması yapıldğı için bir sonraki aşamada private constructor çağırılacaktır fakat yine instance nesnesi oluştrulmayacaktır.Çünkü c# compiler,bir sınıf static constructora sahip olduğunda static instance objesini beforefieldinit olarak işaretlemediğinden henüz yaratma işlemini gerçekleştirmeyecektir.
        //sonrasına static constructor çağırılacaktır.Bu static constructor çağırıldığında instance objesi yaratılacaktır.
        //en son instance propertysi çağırılacaktır ve burada static constructor öncesinde çağırılmış olduğundan instance objesi çoktan yaratılmış olacağından,yaratılmış olan obje geri döndürülecektir.
        //peki nasıl oluyorda bu yapı thread safe olmuş oluyor ?       
		// C# dilinde statik yapıcı metotlar bir AppDomainde ancak ve ancak bir nesne yaratıldığında yada statik bir üye eleman referans edildiğinde bir defaya mahsus olmak üzere çalıştırılır. Yani yukarıdaki versiyonda farklı threadlerin birden fazla SingletonDeseni nesnesi yaratması imkansızdır. Çünkü static üye elemanlar ancak ve ancak bir defa çalıştırılır.
        //Eğer main metodunda ilk Singleton.Instance isteğini bulunursanız yukarıda belirtilen işlemler gerçekleştirilecektir fakat ikinci defa Singleton.Instance isteğinde bulunduğunuzda private ve static constructorlar çalışmayacak yalnızca Instance propertyisi çağırılacak ve daha öncesinde oluşturulup ramde yer tutan objeyi döndürecektir.
        //Bu yüzden multithread uygulamalarda static constructor bir defa çalışacağından yaratılan obje geri döndürülecektir.Diğer thread oluşturulan bu objeyi kullanacaktır.
        private static readonly Singleton instance = new Singleton();
        static Singleton()
        {

        }
        private Singleton()
        {

        }
        public static Singleton Instance
        {
            get
            {
                return instance;
            }
        }
    }
	
		//Kullanım örneği
	
		static void Main(string[] args)
        {
           
            
            Console.WriteLine("Hello World!");
            var obj2 = Singleton.Instance;
        }
```
- 5)Lazy<T> kullanılarak oluşturulan Thread safe yaklaşım.
```c#	

   public sealed class Singleton
    {
        //C# 4.0 versiyonundan sonra gelen   Lazy<T> sınıfı ile Thread safe bir yaklaşım gösterebiliriz.
        //Lazy sınıfı,yaratmak istediğimiz sınıfı ihtiyaç duyduğumuzda yaratmamıza olanak sağlar.
        //lazy.Value diyene kadar o objeden örnek oluşturmaz. lazy.Value isteğinde bulunulduğunda delegate tipinde aldığı fonksiyonu çalıştıracak ve yeni bir singleton objesi yaratacaktır.Bu işlem(yeni nesne yaratma isteği)sonrası default constructor çalışacaktır.Bir sonraki istekte lazy objesinin value değeri ramde tutulduğundan bu işlemler baştan gerçekleşmeyip ramdaki değeri döndürülecektir.
        //Lazy<T> .Net tarafından default özelliği thread safe olarak ayarlanmıştır.Single thread uygulamalarda bu özellik false olarak işaretlenip performans artışı sağlanabilir.
        private static Lazy<Singleton> lazy = new Lazy<Singleton>(() => new Singleton());

        public static Singleton Instance
        {
            get
            {
     
                return lazy.Value;
            }
        }
        
        private Singleton()
        {
            
        }
		//Kullanım mantığını anlamak için aşağıdaki yorum satırlarını açıp yukarıdaki kodları yorum satırına alınız.
        //private static Lazy<Singleton> lazy = new Lazy<Singleton>(() => new Singleton());
        //private static  Lazy<Singleton> lazy =new Lazy<Singleton>(() => ReturnNewObject());
        //private Singleton()
        //{

        //}
        //public static Singleton ReturnNewObject()
        //{
        //    return new Singleton();
        //}
		
		//Kullanım örneği
		 static void Main(string[] args)
        {            
            var obj1 = Singleton.Instance;            
        }
    }
```
	Teşekkürler.
